### Палиндром:

![[Pasted image 20250226225803.png]]

```js
function isPalindrome(str) {
    let left = 0;
    let right = str.length - 1;
    
    while (left < right) {
        while (left < right && !isLetterOrDigit(str[left])) left++;
        while (left < right && !isLetterOrDigit(str[right])) right--;
        
        if (str[left].toLowerCase() !== str[right].toLowerCase()) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

function isLetterOrDigit(char) {
    const code = char.charCodeAt(0);
    return (code >= 48 && code <= 57) || // 0-9
           (code >= 65 && code <= 90) || // A-Z
           (code >= 97 && code <= 122) || // a-z
           (code >= 1040 && code <= 1103); // А-Я, а-я
}

// Примеры использования
console.log(isPalindrome("Казак")); // true
console.log(isPalindrome("А роза упала на лапу Азора")); // true
console.log(isPalindrome("Do geese see God?")); // true
console.log(isPalindrome("Madam, I’m Adam")); // true
console.log(isPalindrome("Hello, world!")); // false

Либо так - 
function isPalindrome(str) {
    let left = 0;
    let right = str.length - 1;
    
    while (left < right) {
        while (left < right && !isAlphanumeric(str[left])) left++;
        while (left < right && !isAlphanumeric(str[right])) right--;
        
        if (str[left].toLowerCase() !== str[right].toLowerCase()) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

function isAlphanumeric(char) {
    return /[a-zA-Z0-9а-яА-Я]/.test(char);
}

```

Этот код игнорирует пробелы, знаки препинания и регистр символов, проверяя строку на палиндром. Функция `isAlphanumeric` фильтрует только буквы и цифры. Итерация осуществляется двумя указателями, что обеспечивает память O(1).

### 2. Варианты прилётов из точки
![[Pasted image 20250226231744.png]]

```js
async function findPath(from, to, fetchFlights, visited = new Set()) {
    if (from === to) return Promise.resolve([from]);
    if (visited.has(from)) return Promise.reject(new Error("No way"));
    
    visited.add(from);
    
    try {
        const destinations = await fetchFlights(from);
        for (const destination of destinations) {
            try {
                const path = await findPath(destination, to, fetchFlights, visited);
                return [from, ...path];
            } catch (err) {
                // Игнорируем ошибки и пробуем следующий маршрут
            }
        }
    } catch (err) {
        return Promise.reject(new Error("No way"));
    }
    
    return Promise.reject(new Error("No way"));
}

// Пример использования:
const graph = {
    A: ["B", "D"],
    B: ["C", "N", "Z"],
    D: ["E", "F"],
    F: ["S"]
};

function fetchFlights(from) {
    return Promise.resolve(graph[from] || []);
}

findPath("A", "N", fetchFlights).then(console.log).catch(console.error); // [ 'A', 'B', 'N' ]
findPath("A", "S", fetchFlights).then(console.log).catch(console.error); // [ 'A', 'D', 'F', 'S' ]
findPath("B", "S", fetchFlights).then(console.log).catch(console.error); // Error: No way

```
Этот код использует рекурсивный поиск с мемоизацией посещенных узлов (`visited`) и возвращает путь в виде массива. Если путь невозможен, возвращается ошибка.

### 3. Содержание Дубликатов

Дана целочисленная последовательность `nums`. Нужно вернуть `true`, если в массиве есть хотя бы одно повторяющееся значение, и `false`, если все элементы уникальны.

#### **Примеры:**

**Пример 1:**  
**Вход:** `nums = [1,2,3,1]`  
**Выход:** `true`  
**Объяснение:** Число `1` встречается дважды (на индексах `0` и `3`).

**Пример 2:**  
**Вход:** `nums = [1,2,3,4]`  
**Выход:** `false`  
**Объяснение:** Все числа уникальны.

**Пример 3:**  
**Вход:** `nums = [1,1,1,3,3,4,3,2,4,2]`  
**Выход:** `true`  
**Объяснение:** Некоторые числа встречаются более одного раза.

---

### **Решение на JavaScript с объяснением**

Мы можем использовать `Set`, который хранит только уникальные значения. Если при добавлении числа в `Set` оно уже там есть, значит, в массиве есть дубликаты.

```javascript
function containsDuplicate(nums) {
    const seen = new Set(); // Создаём множество для хранения уникальных чисел
    
    for (let num of nums) { 
        if (seen.has(num)) { // Если число уже встречалось, возвращаем true
            return true;
        }
        seen.add(num); // Добавляем число в множество
    }
    
    return false; // Если все числа уникальны, возвращаем false
}

// Тесты
console.log(containsDuplicate([1,2,3,1])); // true
console.log(containsDuplicate([1,2,3,4])); // false
console.log(containsDuplicate([1,1,1,3,3,4,3,2,4,2])); // true
```

### **Объяснение кода**

1. **Создаём Set** – используем `Set`, так как он автоматически убирает дубликаты.
2. **Проходим по массиву** – если число уже есть в `Set`, значит, нашли дубликат → возвращаем `true`.
3. **Если прошли весь массив и не нашли дубликатов**, значит, все элементы уникальны → возвращаем `false`.

### **Сложность**

- **Временная сложность:** `O(n)`, так как мы проходим массив один раз.
- **Дополнительная память:** `O(n)`, так как в худшем случае храним все `n` элементов в `Set`.

### 4. Число фибоначи
- 509. Число Фибоначчи Легкая Тема Компании Числа Фибоначчи, обычно обозначаемые как F(n), образуют последовательность, называемую последовательностью Фибоначчи, такую, что каждое число является суммой двух предыдущих, начиная с 0 и 1. То есть,

F(0) = 0, F(1) = 1  
F(n) = F(n - 1) + F(n - 2), для n > 1.

Дано число n, необходимо вычислить F(n).

Пример 1: Вход: n = 2  
Выход: 1  
Пояснение: F(2) = F(1) + F(0) = 1 + 0 = 1.

Пример 2: Вход: n = 3  
Выход: 2  
Пояснение: F(3) = F(2) + F(1) = 1 + 1 = 2.

Пример 3: Вход: n = 4  
Выход: 3  
Пояснение: F(4) = F(3) + F(2) = 2 + 1 = 3.

Ограничения: 0 <= n <= 30

---

Теперь давай решим задачу на JavaScript.

### Решение:

Мы можем решить задачу с использованием простого подхода — динамического программирования, чтобы избежать повторных вычислений.

1. Начнем с того, что создадим массив для хранения чисел Фибоначчи.
2. Заполним первые два элемента массива, так как F(0) = 0 и F(1) = 1.
3. Для каждого последующего числа вычислим его как сумму двух предыдущих чисел.
4. Вернем значение F(n).

### Код на JavaScript:

```javascript
function fib(n) {
    // Если n равно 0 или 1, сразу возвращаем n, так как это базовые случаи
    if (n === 0) return 0;
    if (n === 1) return 1;

    // Создаем массив для хранения значений чисел Фибоначчи
    let fibArray = [0, 1];  // F(0) = 0 и F(1) = 1

    // Заполняем массив для всех чисел от 2 до n
    for (let i = 2; i <= n; i++) {
        // Каждое новое число - сумма двух предыдущих
        fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
    }

    // Возвращаем число Фибоначчи для n
    return fibArray[n];
}

// Примеры
console.log(fib(2)); // Выведет 1
console.log(fib(3)); // Выведет 2
console.log(fib(4)); // Выведет 3
```

### Объяснение:

1. **Базовые случаи:** Мы сразу обрабатываем два базовых случая — если `n == 0`, то возвращаем `0`, а если `n == 1`, то возвращаем `1`.
2. **Массив чисел Фибоначчи:** Создаем массив `fibArray`, где первые два элемента равны 0 и 1. Далее, начиная с 2-го индекса, каждый элемент массива равен сумме двух предыдущих элементов.
3. **Заполнение массива:** В цикле `for` мы перебираем все числа от 2 до `n`, и на каждом шаге вычисляем текущее число как сумму двух предыдущих.
4. **Результат:** После завершения цикла возвращаем значение, которое хранится в `fibArray[n]`.

### Пример:

- Для `n = 4` мы получим `fibArray = [0, 1, 1, 2, 3]`, и вернем `fibArray[4]`, что равно 3.
### 5. Two Sum 
Дан массив целых чисел `nums` и целое число `target`. Нужно вернуть индексы двух чисел из массива, которые в сумме дают значение `target`.

Предполагается, что для каждого ввода существует ровно одно решение, и вы не можете использовать один и тот же элемент дважды.

Вы можете вернуть ответ в любом порядке.

Пример 1: Вход: `nums = [2, 7, 11, 15], target = 9`  
Выход: `[0, 1]`  
Пояснение: Потому что `nums[0] + nums[1] == 9`, мы возвращаем `[0, 1]`.

Пример 2: Вход: `nums = [3, 2, 4], target = 6`  
Выход: `[1, 2]`

Пример 3: Вход: `nums = [3, 3], target = 6`  
Выход: `[0, 1]`

Ограничения:

- 2 <= nums.length <= 10⁴
- -10⁹ <= nums[i] <= 10⁹
- -10⁹ <= target <= 10⁹
- Существует только одно правильное решение.

Дополнительный вопрос: Можете ли вы предложить алгоритм с временной сложностью лучше, чем O(n²)?

---

### Решение:

Для того, чтобы решить задачу эффективно, можно использовать хеш-таблицу (или объект в JavaScript) для хранения чисел, которые мы уже встречали, и их индексов. Это позволит нам искать пару чисел за время O(1), что значительно ускоряет решение по сравнению с методом вложенных циклов.

Алгоритм:

1. Мы будем перебирать элементы массива.
2. Для каждого элемента будем вычислять разницу между `target` и текущим элементом. Если эта разница уже встречалась, значит, мы нашли пару чисел, которые в сумме дают `target`, и можно вернуть их индексы.
3. Если разница не встречалась, добавляем текущий элемент и его индекс в хеш-таблицу для дальнейших проверок.

### Код на JavaScript:

```javascript
function twoSum(nums, target) {
    let map = new Map();  // Хеш-таблица для хранения элементов и их индексов
    
    for (let i = 0; i < nums.length; i++) {
        let complement = target - nums[i];  // Вычисляем недостающее число
        
        // Проверяем, есть ли уже в хеш-таблице недостающее число
        if (map.has(complement)) {
            // Если есть, возвращаем индексы текущего числа и недостающего
            return [map.get(complement), i];
        }
        
        // Если нет, добавляем текущий элемент в хеш-таблицу
        map.set(nums[i], i);
    }
    
    // Возвращаем пустой массив, если решение не найдено (по условию задачи это не должно произойти)
    return [];
}

// Пример 1
console.log(twoSum([2, 7, 11, 15], 9));  // Выведет: [0, 1]

// Пример 2
console.log(twoSum([3, 2, 4], 6));  // Выведет: [1, 2]

// Пример 3
console.log(twoSum([3, 3], 6));  // Выведет: [0, 1]
```

### Объяснение:

1. **Хеш-таблица (Map):** Используем объект `map` для хранения чисел, которые мы уже встретили, и их индексов. В качестве ключей используем значения массива `nums`, а в качестве значений — индексы этих чисел.
    
2. **Перебор массива:** Проходим по каждому элементу массива `nums`. Для каждого элемента вычисляем разницу `complement = target - nums[i]`. Это число должно быть уже в нашем хранилище (в хеш-таблице).
    
3. **Проверка:** Если разница уже есть в `map`, то мы нашли пару чисел, которые в сумме дают `target`. Возвращаем индексы этих чисел: индекс текущего элемента (`i`) и индекс найденного числа (`map.get(complement)`).
    
4. **Если разницы нет:** Добавляем текущий элемент и его индекс в хеш-таблицу для дальнейших проверок.
    
5. **Время работы:** Алгоритм работает за O(n), так как мы проходим по массиву всего один раз, а операции вставки и поиска в хеш-таблице происходят за O(1) в среднем.
    

### Пример:

- Для входа `[2, 7, 11, 15]` и `target = 9` разница для числа `2` будет `7`, она найдется в хеш-таблице на второй итерации, и вернутся индексы `[0, 1]`.
  
### Лёгкий полиндром


Дано целое число `x`. Нужно вернуть `true`, если число является палиндромом, и `false`, если нет.

Пример 1: Вход: `x = 121`  
Выход: `true`  
Пояснение: 121 читается одинаково слева направо и справа налево.

Пример 2: Вход: `x = -121`  
Выход: `false`  
Пояснение: Слева направо читается как -121, а справа налево как 121-. Это не палиндром.

Пример 3: Вход: `x = 10`  
Выход: `false`  
Пояснение: Читается как 01 справа налево. Это не палиндром.

Ограничения:

- -2^31 <= x <= 2^31 - 1

Дополнительный вопрос: Можете ли вы решить задачу без преобразования числа в строку?

---

### Решение:

Чтобы проверить, является ли число палиндромом, без преобразования числа в строку, можно воспользоваться следующей идеей:

1. Если число отрицательное, оно не может быть палиндромом, так как символ минус будет стоять только в начале числа.
2. Если число заканчивается на 0, и оно не равно 0, то число также не может быть палиндромом, так как оно будет выглядеть по-другому при прочтении справа налево.
3. Мы будем извлекать цифры числа с конца и сравнивать их с цифрами числа с начала, пока не достигнем середины.

Для этого мы можем перевести число в его вторую половину и сравнить её с первой половиной.

### Алгоритм:

1. Проверяем, является ли число отрицательным или заканчивается ли оно на 0 (кроме случая, когда оно равно 0).
2. Создаем переменную для второй половины числа.
3. Извлекаем цифры с конца числа и сравниваем их с цифрами из первой половины.
4. Если в какой-то момент числа не совпадают, возвращаем `false`. Если все совпало, возвращаем `true`.

### Код на JavaScript:

```javascript
function isPalindrome(x) {
    // Если число отрицательное или заканчивается на 0 (кроме случая, когда число равно 0)
    if (x < 0 || (x % 10 === 0 && x !== 0)) {
        return false;
    }

    let reversedHalf = 0;
    // Извлекаем цифры из второй половины числа и сравниваем с первой половиной
    while (x > reversedHalf) {
        reversedHalf = reversedHalf * 10 + x % 10;  // Добавляем последнюю цифру в перевёрнутую половину
        x = Math.floor(x / 10);  // Убираем последнюю цифру из числа
    }

    // Если число имеет четную длину, то x должно стать равно reversedHalf, иначе, если длина нечетная, проверяем без средней цифры
    return x === reversedHalf || x === Math.floor(reversedHalf / 10);
}

// Пример 1
console.log(isPalindrome(121));  // Выведет: true

// Пример 2
console.log(isPalindrome(-121));  // Выведет: false

// Пример 3
console.log(isPalindrome(10));  // Выведет: false
```

### Объяснение:

1. **Проверка на отрицательные числа и числа, заканчивающиеся на 0:** Если число отрицательное или оно заканчивается на 0 (и при этом не равно 0), то это сразу означает, что оно не может быть палиндромом.
    
2. **Извлечение второй половины числа:** Мы используем переменную `reversedHalf` для хранения второй половины числа в перевернутом виде. В цикле мы извлекаем последнюю цифру числа, добавляем её в `reversedHalf` и убираем её из `x`.
    
3. **Проверка на палиндром:** В конце цикла проверяем, совпадает ли первая половина числа с перевернутой второй половиной. Если длина числа нечётная, то средняя цифра не имеет значения, поэтому мы делим `reversedHalf` на 10 (чтобы удалить эту цифру) и сравниваем.
    
4. **Время работы:** Алгоритм работает за O(log(x)) времени, так как в цикле мы делим число на 10, уменьшая его на порядок на каждой итерации.
    

### Пример:

- Для числа `121` мы извлекаем вторую половину (`reversedHalf = 21`), и сравниваем её с первой половиной, и они совпадают. Ответ будет `true`.
- Для числа `-121` сразу возвращаем `false`, так как оно отрицательное.
- Для числа `10` извлекаем последнюю цифру (`reversedHalf = 1`), и остаток от деления числа также не совпадает, поэтому ответ `false`.